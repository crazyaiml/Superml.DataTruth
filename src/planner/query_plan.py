"""
Query Plan Models

Defines the structured query plan that the LLM must generate.
"""

from datetime import date, datetime
from enum import Enum
from typing import Any, Dict, List, Literal, Optional

from pydantic import BaseModel, Field


class FilterOperator(str, Enum):
    """SQL filter operators."""

    EQUAL = "="
    NOT_EQUAL = "!="
    GREATER_THAN = ">"
    GREATER_EQUAL = ">="
    LESS_THAN = "<"
    LESS_EQUAL = "<="
    IN = "in"
    NOT_IN = "not_in"
    LIKE = "like"
    NOT_LIKE = "not_like"
    IS_NULL = "is_null"
    IS_NOT_NULL = "is_not_null"


class FilterCondition(BaseModel):
    """A filter condition for the query."""

    field: str = Field(description="Field name to filter on")
    operator: FilterOperator = Field(description="Comparison operator")
    value: Any = Field(description="Value to compare against")

    def __str__(self) -> str:
        """String representation of filter."""
        return f"{self.field} {self.operator.value} {self.value}"


class TimeRange(BaseModel):
    """Time range specification."""

    start_date: Optional[date] = Field(None, description="Start date (inclusive)")
    end_date: Optional[date] = Field(None, description="End date (inclusive)")
    period: Optional[str] = Field(
        None, description="Relative period like 'last_quarter', 'this_year'"
    )

    def __str__(self) -> str:
        """String representation."""
        if self.period:
            return self.period
        return f"{self.start_date} to {self.end_date}"


class QueryPlan(BaseModel):
    """
    Structured query plan generated by LLM.

    This is the contract between NL input and SQL generation.
    The LLM MUST output this structure, not raw SQL.
    """

    metric: str = Field(description="Primary metric to calculate (from semantic layer)")
    dimensions: List[str] = Field(
        default_factory=list, description="Dimensions to group by (from semantic layer)"
    )
    time_range: Optional[TimeRange] = Field(
        None, description="Time range for the query"
    )
    time_grain: Optional[str] = Field(
        None, description="Temporal aggregation granularity: 'day', 'week', 'month', 'quarter', 'year'. Use when query mentions 'daily', 'weekly', 'monthly', 'quarterly', 'yearly' patterns."
    )
    filters: List[FilterCondition] = Field(
        default_factory=list, description="Additional filter conditions"
    )
    order_by: Dict[str, Literal["asc", "desc"]] = Field(
        default_factory=dict, description="Fields to order by with direction"
    )
    limit: Optional[int] = Field(None, description="Maximum number of rows to return")
    offset: Optional[int] = Field(None, description="Number of rows to skip (for ordinal queries like 'second highest')")

    # Metadata
    intent: Optional[str] = Field(
        None, description="Interpreted intent of the user's question"
    )
    assumptions: List[str] = Field(
        default_factory=list,
        description="Assumptions made (e.g., 'last_quarter' = Q3 2024)",
    )
    needs_clarification: bool = Field(
        False, description="Whether the query needs user clarification"
    )
    clarification_question: Optional[str] = Field(
        None, description="Question to ask user if clarification needed"
    )

    def is_valid(self) -> bool:
        """Check if query plan is valid and executable."""
        if not self.metric:
            return False
        if self.needs_clarification:
            return False
        return True

    def summary(self) -> str:
        """Get human-readable summary of the plan."""
        parts = [f"Calculate {self.metric}"]

        if self.dimensions:
            parts.append(f"grouped by {', '.join(self.dimensions)}")

        if self.time_range:
            parts.append(f"for {self.time_range}")

        if self.filters:
            parts.append(f"with filters: {', '.join(str(f) for f in self.filters)}")

        if self.order_by:
            order_strs = [f"{field} {direction}" for field, direction in self.order_by.items()]
            parts.append(f"ordered by {', '.join(order_strs)}")

        if self.limit:
            parts.append(f"limit {self.limit}")

        return " ".join(parts)


class IntentExtraction(BaseModel):
    """Result of intent extraction from user question."""

    query_plan: QueryPlan = Field(description="The structured query plan")
    confidence: float = Field(
        description="Confidence score 0-1 for the extraction", ge=0.0, le=1.0
    )
    entities_found: Dict[str, List[str]] = Field(
        default_factory=dict,
        description="Entities extracted (metrics, dimensions, time periods, etc.)",
    )
