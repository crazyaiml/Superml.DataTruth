"""
User Manager

Manages user profiles, roles, and goals with database persistence.
"""

import logging
import uuid
import hashlib
from typing import List, Optional
from datetime import datetime

from src.user.models import (
    UserProfile, UserRole, CreateUserRequest, 
    UpdateUserRequest, ROLE_GOAL_SUGGESTIONS
)
from src.database.internal_db import InternalDB

logger = logging.getLogger(__name__)

_user_manager = None


class UserManager:
    """Manages user profiles with roles and goals."""
    
    def __init__(self):
        """Initialize user manager and ensure table exists."""
        self._ensure_users_table()
        self._create_default_admin()
    
    def _ensure_users_table(self):
        """Create users table if it doesn't exist."""
        try:
            query = """
            CREATE TABLE IF NOT EXISTS users (
                id VARCHAR(100) PRIMARY KEY,
                username VARCHAR(100) UNIQUE NOT NULL,
                email VARCHAR(255) UNIQUE NOT NULL,
                password_hash VARCHAR(255) NOT NULL,
                full_name VARCHAR(255) NOT NULL,
                role VARCHAR(50) NOT NULL,
                goals TEXT[],
                department VARCHAR(100),
                preferences JSONB DEFAULT '{}',
                is_active BOOLEAN DEFAULT TRUE,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
            """
            InternalDB.execute_query(query)
            logger.info("✓ Users table ready")
        except Exception as e:
            logger.error(f"Failed to create users table: {e}")
    
    def _create_default_admin(self):
        """Create default admin user if no admin exists."""
        try:
            # Check if any admin user exists
            admins = InternalDB.execute_query(
                "SELECT id FROM users WHERE role = 'admin' AND is_active = TRUE"
            )
            
            if not admins:
                # Create default admin (id auto-generated by database)
                password_hash = self._hash_password("admin123")  # Default password
                
                query = """
                INSERT INTO users (
                    username, email, password_hash, full_name, 
                    role, goals, department, is_active
                ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                """
                
                InternalDB.execute_query(
                    query,
                    (
                        "admin",
                        "admin@datatruth.com",  # Use proper domain
                        password_hash,
                        "System Administrator",
                        "admin",
                        ["Manage system configuration", "Monitor system health", "Manage user access"],
                        "IT",
                        True
                    )
                )
                
                logger.info("✓ Created default admin user (username: admin, password: admin123)")
                logger.warning("⚠️  IMPORTANT: Please change the default admin password!")
        
        except Exception as e:
            logger.error(f"Failed to create default admin: {e}")
    
    def _hash_password(self, password: str) -> str:
        """Hash password using bcrypt."""
        import bcrypt
        return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
    
    def _verify_password_hash(self, password: str, password_hash: str) -> bool:
        """Verify password against bcrypt hash."""
        import bcrypt
        try:
            return bcrypt.checkpw(password.encode('utf-8'), password_hash.encode('utf-8'))
        except Exception:
            # Fall back to SHA-256 for legacy passwords
            return hashlib.sha256(password.encode()).hexdigest() == password_hash
    
    def _row_to_profile(self, row: dict) -> UserProfile:
        """Convert database row to UserProfile."""
        return UserProfile(
            id=str(row['id']),  # Convert SERIAL id to string
            username=row['username'],
            email=row['email'],
            full_name=row.get('full_name') or '',
            role=UserRole(row['role']) if row.get('role') else UserRole.ANALYST,
            goals=row.get('goals') or [],
            department=row.get('department'),
            preferences=row.get('preferences') or {},
            is_active=row.get('is_active', True),
            created_at=row.get('created_at'),
            updated_at=row.get('updated_at')
        )
    
    def create_user(self, request: CreateUserRequest) -> UserProfile:
        """Create a new user."""
        try:
            # Check if username or email exists
            existing = InternalDB.execute_query(
                "SELECT id FROM users WHERE username = %s OR email = %s",
                (request.username, request.email)
            )
            if existing:
                raise ValueError("Username or email already exists")
            
            password_hash = self._hash_password(request.password)
            
            query = """
            INSERT INTO users (
                username, email, password_hash, full_name, 
                role, goals, department, is_active
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
            RETURNING id
            """
            
            result = InternalDB.execute_query(
                query,
                (
                    request.username,
                    request.email,
                    password_hash,
                    request.full_name,
                    request.role.value,
                    request.goals,
                    request.department,
                    True
                ),
                fetch_one=True
            )
            
            if not result:
                logger.error("No result returned from INSERT with RETURNING")
                raise ValueError("Failed to create user - no ID returned")
            
            # Extract user_id from the returned row
            if isinstance(result, dict):
                user_id = str(result['id'])
            elif isinstance(result, (list, tuple)):
                user_id = str(result[0])
            else:
                logger.error(f"Unexpected result type: {type(result)}, value: {result}")
                raise ValueError("Failed to extract user ID from database result")
            
            logger.info(f"✓ Created user: {request.username} (id: {user_id}, role: {request.role.value})")
            
            # Fetch and return the complete user profile
            return self.get_user(user_id)
        
        except Exception as e:
            logger.error(f"Failed to create user: {e}")
            raise
    
    def get_user(self, user_id: str) -> Optional[UserProfile]:
        """Get user by ID."""
        try:
            rows = InternalDB.execute_query(
                "SELECT * FROM users WHERE id = %s",
                (user_id,)  # ID is VARCHAR/UUID string
            )
            
            if not rows:
                return None
            
            return self._row_to_profile(rows[0])
        
        except Exception as e:
            logger.error(f"Failed to get user {user_id}: {e}")
            return None
    
    def get_user_by_username(self, username: str) -> Optional[UserProfile]:
        """Get user by username."""
        try:
            rows = InternalDB.execute_query(
                "SELECT * FROM users WHERE username = %s",
                (username,)
            )
            
            if not rows:
                return None
            
            return self._row_to_profile(rows[0])
        
        except Exception as e:
            logger.error(f"Failed to get user by username {username}: {e}")
            return None
    
    def list_users(self, include_inactive: bool = False) -> List[UserProfile]:
        """List all users."""
        try:
            if include_inactive:
                rows = InternalDB.execute_query("SELECT * FROM users ORDER BY created_at DESC")
            else:
                rows = InternalDB.execute_query(
                    "SELECT * FROM users WHERE is_active = TRUE ORDER BY created_at DESC"
                )
            
            if not rows:
                return []
            
            # Use the helper method to properly convert each row
            users = [self._row_to_profile(row) for row in rows]
            return users
        
        except Exception as e:
            logger.error(f"Failed to list users: {e}")
            return []
    
    def update_user(self, user_id: str, request: UpdateUserRequest) -> Optional[UserProfile]:
        """Update user details."""
        try:
            # Build dynamic update query
            updates = []
            params = []
            
            if request.email is not None:
                updates.append("email = %s")
                params.append(request.email)
            
            if request.full_name is not None:
                updates.append("full_name = %s")
                params.append(request.full_name)
            
            if request.role is not None:
                updates.append("role = %s")
                params.append(request.role.value)
            
            if request.goals is not None:
                updates.append("goals = %s")
                params.append(request.goals)
            
            if request.department is not None:
                updates.append("department = %s")
                params.append(request.department)
            
            if request.preferences is not None:
                updates.append("preferences = %s")
                params.append(request.preferences)
            
            if request.is_active is not None:
                updates.append("is_active = %s")
                params.append(request.is_active)
            
            if not updates:
                return self.get_user(user_id)
            
            updates.append("updated_at = CURRENT_TIMESTAMP")
            params.append(user_id)
            
            query = f"UPDATE users SET {', '.join(updates)} WHERE id = %s"
            InternalDB.execute_query(query, tuple(params))
            
            logger.info(f"✓ Updated user: {user_id}")
            return self.get_user(user_id)
        
        except Exception as e:
            logger.error(f"Failed to update user {user_id}: {e}")
            raise
    
    def delete_user(self, user_id: str, soft_delete: bool = True) -> bool:
        """Delete user (soft or hard delete)."""
        try:
            if soft_delete:
                InternalDB.execute_query(
                    "UPDATE users SET is_active = FALSE, updated_at = CURRENT_TIMESTAMP WHERE id = %s",
                    (user_id,)
                )
                logger.info(f"✓ Soft deleted user: {user_id}")
            else:
                InternalDB.execute_query("DELETE FROM users WHERE id = %s", (user_id,))
                logger.info(f"✓ Hard deleted user: {user_id}")
            
            return True
        
        except Exception as e:
            logger.error(f"Failed to delete user {user_id}: {e}")
            return False
    
    def get_goal_suggestions(self, role: UserRole) -> List[str]:
        """Get suggested goals for a role."""
        return ROLE_GOAL_SUGGESTIONS.get(role, [])
    
    def verify_password(self, username: str, password: str) -> Optional[UserProfile]:
        """Verify user credentials using bcrypt."""
        try:
            # First get the user and their stored hash
            rows = InternalDB.execute_query(
                "SELECT * FROM users WHERE username = %s AND is_active = TRUE",
                (username,)
            )
            
            if not rows:
                return None
            
            user_row = rows[0]
            stored_hash = user_row.get('password_hash', '')
            
            # Verify password against stored hash
            if not self._verify_password_hash(password, stored_hash):
                return None
            
            return self._row_to_profile(user_row)
        
        except Exception as e:
            logger.error(f"Failed to verify password: {e}")
            return None


def get_user_manager() -> UserManager:
    """Get or create singleton UserManager instance."""
    global _user_manager
    if _user_manager is None:
        _user_manager = UserManager()
    return _user_manager
